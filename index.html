<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Friend Flap â€” Mobile Friendly</title>
<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;font-family:Arial,sans-serif;}
  body{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;background:linear-gradient(180deg,#d7e8f2,#eef7ff);}
  .topbar{width:100%;display:flex;justify-content:space-between;padding:8px 12px;box-sizing:border-box;}
  .scoreCard{background:rgba(255,255,255,0.9);padding:6px 12px;border-radius:12px;font-weight:700;}
  .controls{display:flex;gap:4px;}
  button{padding:8px 12px;border-radius:12px;border:none;font-weight:700;background:#2c5530;color:white;flex:1;}
  .canvasWrap{width:100%;flex:1;position:relative;}
  canvas{width:100%;height:100%;display:block;}
</style>
</head>
<body>
  <div class="topbar">
    <div class="scoreCard">Score: <span id="score">0</span></div>
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="restartBtn">Restart</button>
    </div>
  </div>
  <div class="canvasWrap">
    <canvas id="c"></canvas>
  </div>

<script>
const CONFIG={
  pipeGap:240, pipeWidth:110, pipeSpeed:180, spawnInterval:1.8,
  gravity:900, flapImpulse:-380, playerSize:84, groundHeight:80
};

const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
let W=window.innerWidth, H=window.innerHeight-canvas.offsetTop;
canvas.width=W; canvas.height=H;

window.addEventListener('resize',()=>{
  W=window.innerWidth;
  H=window.innerHeight-canvas.offsetTop;
  canvas.width=W;
  canvas.height=H;
});

const friendImg=new Image();
friendImg.src='/BC-BJwxn_400x400-removebg-preview.png';

const state={
  running:false,
  last:0,
  player:{x:W/4, y:H/2, vy:0, size:CONFIG.playerSize},
  pipes:[],
  spawnTimer:0,
  score:0
};

function spawnPipe(){
  const top=Math.random()*(H-CONFIG.groundHeight-CONFIG.pipeGap-60)+40;
  state.pipes.push({x:W+80, top:top, bottom:top+CONFIG.pipeGap, w:CONFIG.pipeWidth, passed:false});
}

function flap(){state.player.vy=CONFIG.flapImpulse;}

document.addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault(); flap();}});
canvas.addEventListener('click',flap);
canvas.addEventListener('touchstart',e=>{e.preventDefault(); flap();},{passive:false});

const scoreEl=document.getElementById('score');
const startBtn=document.getElementById('startBtn');
const pauseBtn=document.getElementById('pauseBtn');
const restartBtn=document.getElementById('restartBtn');
startBtn.onclick=()=>startGame();
pauseBtn.onclick=()=>togglePause();
restartBtn.onclick=()=>startGame();

function startGame(){
  state.running=true;
  state.last=performance.now();
  state.player.y=H/2;
  state.player.vy=0;
  state.pipes=[];
  state.spawnTimer=0;
  state.score=0;
  scoreEl.textContent='0';
  requestAnimationFrame(loop);
}

function togglePause(){
  state.running=!state.running;
  if(state.running) state.last=performance.now();
  requestAnimationFrame(loop);
}

function loop(ts){
  if(!state.running) return;
  const dt=Math.min(0.035,(ts-state.last)/1000);
  state.last=ts;
  update(dt);
  render();
  if(state.running) requestAnimationFrame(loop);
}

function update(dt){
  state.player.vy+=CONFIG.gravity*dt;
  state.player.y+=state.player.vy*dt;

  if(state.player.y+state.player.size/2>H-CONFIG.groundHeight){
    state.player.y=H-CONFIG.groundHeight-state.player.size/2;
    state.running=false;
  }
  if(state.player.y-state.player.size/2<0){
    state.player.y=state.player.size/2;
    state.player.vy=0;
  }

  state.spawnTimer+=dt;
  if(state.spawnTimer>=CONFIG.spawnInterval){ spawnPipe(); state.spawnTimer=0; }

  for(let i=state.pipes.length-1;i>=0;i--){
    const p=state.pipes[i];
    p.x-=CONFIG.pipeSpeed*dt;

    if(!p.passed && p.x+p.w<state.player.x-state.player.size/2){p.passed=true; state.score++; scoreEl.textContent=state.score;}
    if(p.x+p.w<-50) state.pipes.splice(i,1);

    const px=state.player.x-state.player.size/2, py=state.player.y-state.player.size/2;
    if(rectIntersect(px,py,state.player.size,state.player.size,p.x,0,p.w,p.top) ||
       rectIntersect(px,py,state.player.size,state.player.size,p.x,p.bottom,p.w,H-p.bottom-CONFIG.groundHeight)){
      state.running=false;
    }
  }
}

function rectIntersect(ax,ay,aw,ah,bx,by,bw,bh){return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;}

function render(){
  ctx.clearRect(0,0,W,H);
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#eaf6ff'); g.addColorStop(0.6,'#d8eefc'); g.addColorStop(1,'#cfe9f6');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // ground
  ctx.fillStyle='#9dd7bf'; ctx.fillRect(0,H-CONFIG.groundHeight,W,CONFIG.groundHeight);

  // pipes
  ctx.fillStyle='#1e8a6d';
  state.pipes.forEach(p=>{
    ctx.fillRect(p.x,0,p.w,p.top);
    ctx.fillRect(p.x,p.bottom,p.w,H-p.bottom-CONFIG.groundHeight);
  });

  // player
  ctx.save();
  const px=state.player.x, py=state.player.y, sz=state.player.size;
  ctx.beginPath();
  ctx.arc(px,py,sz/2,0,Math.PI*2);
  ctx.closePath();
  ctx.clip();
  if(friendImg.complete) ctx.drawImage(friendImg,px-sz/2,py-sz/2,sz,sz);
  ctx.restore();
}
</script>
</body>
</html>
